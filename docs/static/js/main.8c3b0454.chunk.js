(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{15:function(e,n,t){},16:function(e,n,t){},17:function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),i=t(5),o=t.n(i),c=(t(15),t(2)),s=t(3),l=t(7),f=t(6),v=t(1),x=t(8),u=function(){function e(n){Object(c.a)(this,e),this._gl=n}return Object(s.a)(e,[{key:"getGLContext",value:function(){return this._gl}},{key:"createShader",value:function(e,n){var t=this._gl,r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)?r:null}},{key:"createProgram",value:function(e){var n=this._gl,t=n.createProgram();return e.forEach(function(e){n.attachShader(t,e)}),n.linkProgram(t),n.getProgramParameter(t,n.LINK_STATUS)?(n.useProgram(t),t):null}},{key:"createBuffer",value:function(e,n){var t=this._gl,r=t.createBuffer();return t.bindBuffer(e,r),t.bufferData(e,n,t.STATIC_DRAW),t.bindBuffer(e,null),r}}]),e}(),m="\nattribute vec3 position;\n\nvoid main() {\n\tgl_Position = vec4(position, 1.0); \n}",g=function(e){return'\nprecision mediump float;\nconst float PI = 3.1415926;\nconst vec2 offset = vec2(0.5);\nuniform float time;\nuniform vec2  resolution;\n\n// Ref: https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n\t// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n\t// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n\t// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n\t// Normalise gradients implicitly by scaling m\n\t// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\t// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec3 hsv(float h, float s, float v){\n\tvec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n\treturn v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\n// Ref: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Ref: https://thebookofshaders.com/05/\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\n// Ref: https://thebookofshaders.com/10/\nfloat random (vec2 st) {\n\treturn fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat function(in float x, in vec2 uv) {\n\tfloat y = 0.;\n\t'.concat(e,"\n\treturn y;\n}\n\nvoid main() {\n\tvec2 uv = (gl_FragCoord.xy / resolution.xy) - offset;\n\tuv *= 2.5;\n\n\tvec3 color = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\n\t// Plot\n\tfloat line = plot(uv, function(uv.x, uv));\n\tcolor = (1.0 - line) * color + line * white;\n\n\tgl_FragColor = vec4(color, 1.0);\n}")},h=(t(16),new Float32Array([-1,1,0,1,1,0,-1,-1,0,1,-1,0])),d=new Int16Array([0,2,1,1,2,3]),y=function(e){function n(e){var t;return Object(c.a)(this,n),(t=Object(l.a)(this,Object(f.a)(n).call(this,e))).state={fomula:""},t.canvas=a.a.createRef(),t.nisgl=null,t.program=null,t.uniform=[],t.shaders=[],t.time=0,t.startTime=0,t.handleChangeText=t.handleChangeText.bind(Object(v.a)(t)),t.resize=t.resize.bind(Object(v.a)(t)),t.draw=t.draw.bind(Object(v.a)(t)),t}return Object(x.a)(n,e),Object(s.a)(n,[{key:"handleChangeText",value:function(e){var n=this;e.persist(),this.setState(function(n){return{fomula:e.target.value}},function(){var e=n.nisgl.getGLContext(),t=n.nisgl.createShader(e.VERTEX_SHADER,m),r=n.nisgl.createShader(e.FRAGMENT_SHADER,g(n.state.fomula));if(t&&r){n.shaders.forEach(function(t){e.detachShader(n.program,t)}),n.shaders=[],n.shaders.push(t),n.shaders.push(r),n.program=n.nisgl.createProgram(n.shaders),n.uniform=[],n.uniform.push(e.getUniformLocation(n.program,"time")),n.uniform.push(e.getUniformLocation(n.program,"resolution"));var a=n.nisgl.createBuffer(e.ARRAY_BUFFER,h),i=n.nisgl.createBuffer(e.ELEMENT_ARRAY_BUFFER,d),o=e.getAttribLocation(n.program,"position");e.bindBuffer(e.ARRAY_BUFFER,a),e.enableVertexAttribArray(o),e.vertexAttribPointer(o,3,e.FLOAT,!1,0,0),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,i)}})}},{key:"componentDidMount",value:function(){var e=this.canvas.current.getContext("webgl");this.nisgl=new u(e),this.shaders.push(this.nisgl.createShader(e.VERTEX_SHADER,m)),this.shaders.push(this.nisgl.createShader(e.FRAGMENT_SHADER,g(""))),this.program=this.nisgl.createProgram(this.shaders),this.uniform.push(e.getUniformLocation(this.program,"time")),this.uniform.push(e.getUniformLocation(this.program,"resolution"));var n=this.nisgl.createBuffer(e.ARRAY_BUFFER,h),t=this.nisgl.createBuffer(e.ELEMENT_ARRAY_BUFFER,d),r=e.getAttribLocation(this.program,"position");e.bindBuffer(e.ARRAY_BUFFER,n),e.enableVertexAttribArray(r),e.vertexAttribPointer(r,3,e.FLOAT,!1,0,0),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.clearColor(0,0,0,1),this.startTime=(new Date).getTime(),this.resize(),this.draw()}},{key:"resize",value:function(){var e=this.canvas.current.clientWidth,n=this.canvas.current.clientHeight;this.canvas.current.width=e,this.canvas.current.height=n}},{key:"draw",value:function(){var e=this.canvas.current,n=e.clientHeight,t=e.clientWidth,r=this.nisgl.getGLContext();this.time=.001*((new Date).getTime()-this.startTime),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t,n),r.uniform1f(this.uniform[0],this.time),r.uniform2fv(this.uniform[1],[t,n]),r.drawElements(r.TRIANGLES,6,r.UNSIGNED_SHORT,0),r.flush(),requestAnimationFrame(this.draw)}},{key:"render",value:function(){return a.a.createElement("div",{className:"App"},a.a.createElement("canvas",{id:"webgl",ref:this.canvas}),a.a.createElement("div",{className:"params"},a.a.createElement("textarea",{rows:"4",cols:"50",name:"fomula",placeholder:"y = sin(x);",onChange:this.handleChangeText,value:this.state.fomula})),a.a.createElement("div",{className:"assignedParams"},a.a.createElement("p",null,"Assigned Parameters:",a.a.createElement("br",null),"float time - Count up the elapsed time (0.000)",a.a.createElement("br",null),"float PI - (3.1415926);",a.a.createElement("br",null),"vec2 uv - By default, it has been multiplied by 2.5",a.a.createElement("br",null),a.a.createElement("br",null),"Functions:",a.a.createElement("br",null),a.a.createElement("a",{href:"https://github.com/Nismit/fomula-visualizer/blob/master/src/fragment.js#L33-L79",target:"_blank",rel:"noopener noreferrer"},"float snoise(vec2 v)"),a.a.createElement("br",null),a.a.createElement("a",{href:"https://github.com/Nismit/fomula-visualizer/blob/master/src/fragment.js#L112-L149",target:"_blank",rel:"noopener noreferrer"},"float cnoise(vec2 P)"),a.a.createElement("br",null),a.a.createElement("a",{href:"https://github.com/Nismit/fomula-visualizer/blob/master/src/fragment.js#L152-L189",target:"_blank",rel:"noopener noreferrer"},"float pnoise(vec2 P, vec2 rep)"),a.a.createElement("br",null))),a.a.createElement("footer",null,"\xa9 Fomula Visualizer | Made by ",a.a.createElement("a",{href:"https://github.com/Nismit",target:"_blank",rel:"noopener noreferrer"},"Nismit")))}}]),n}(a.a.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(a.a.createElement(y,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})},9:function(e,n,t){e.exports=t(17)}},[[9,1,2]]]);
//# sourceMappingURL=main.8c3b0454.chunk.js.map